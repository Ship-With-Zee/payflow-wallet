# ============================================
# Container Image Scanning CronJob (Trivy)
# ============================================
# Purpose: Automated security scanning of container images
# Why: Detects vulnerabilities in container images before they reach production
# When: Runs daily at 3 AM UTC
# What happens without it: Vulnerable images deployed unknowingly, security risks

apiVersion: batch/v1  # Kubernetes batch API version
kind: CronJob  # Resource type - runs scheduled jobs repeatedly
metadata:
  name: image-scanning  # CronJob name
  namespace: payflow  # Namespace
spec:
  # ============================================
  # Cron Schedule
  # ============================================
  schedule: "0 3 * * *"  # Daily at 3 AM UTC
  # Format: minute hour day month day-of-week
  # 0 = minute (0)
  # 3 = hour (3 AM)
  # * = day of month (every day)
  # * = month (every month)
  # * = day of week (every day)
  # Why 3 AM: Low traffic time, scans complete before business hours
  
  # ============================================
  # Job History Limits
  # ============================================
  successfulJobsHistoryLimit: 3  # Keep last 3 successful scans for comparison
  failedJobsHistoryLimit: 3      # Keep last 3 failed scans for troubleshooting
  
  # ============================================
  # Job Template
  # ============================================
  jobTemplate:
    spec:
      template:
        spec:
          restartPolicy: OnFailure  # Retry if scan fails
          containers:
          - name: trivy-scanner  # Container name
            # ============================================
            # Trivy Image
            # ============================================
            # Trivy: Open-source security scanner by Aqua Security
            # Scans container images for known vulnerabilities (CVEs)
            # Supports multiple formats (JSON, table, etc.)
            image: aquasec/trivy:latest  # Official Trivy image
            
            # ============================================
            # Command and Script
            # ============================================
            command:
            - /bin/sh
            - -c
            - |
              set -e  # Exit on any error (but we use || true for individual scans)
              echo "Starting image vulnerability scan..."
              
              # ============================================
              # Setup Report Directory
              # ============================================
              # Create directory for scan reports
              # Reports are stored in emptyDir volume (temporary, lost on pod restart)
              # In production: Mount persistent volume or upload to S3
              mkdir -p /reports
              
              # ============================================
              # Images to Scan
              # ============================================
              # List of all PayFlow container images to scan
              # These should match the images used in deployments
              # Using space-separated list (compatible with Alpine sh)
              IMAGES="payflow/api-gateway:latest payflow/auth-service:latest payflow/wallet-service:latest payflow/transaction-service:latest payflow/notification-service:latest payflow/frontend:latest"
              
              # ============================================
              # Scan Each Image
              # ============================================
              # Loop through each image and scan it
              for IMAGE in $IMAGES; do
                echo "Scanning $IMAGE..."
                
                # Generate report filename
                # Convert image name to filename-safe format
                # Example: "payflow/api-gateway:latest" -> "payflow-api-gateway-latest-20251225.json"
                REPORT_FILE="/reports/$(echo $IMAGE | tr '/:' '-')-$(date +%Y%m%d).json"
                # tr '/:' '-': Translates / and : to - (filename-safe)
                # date +%Y%m%d: Current date in YYYYMMDD format
                
                # ============================================
                # Run Trivy Scan
                # ============================================
                # Scan the image for vulnerabilities
                # Output format: JSON (easy to parse)
                # Save report to file
                # Only report HIGH and CRITICAL vulnerabilities (reduces noise, focuses on serious issues)
                # Continue even if scan fails (don't stop other scans)
                trivy image --format json --output "$REPORT_FILE" --severity HIGH,CRITICAL "$IMAGE" || true
                
                # ============================================
                # Generate Summary
                # ============================================
                # Count vulnerabilities found in the report
                if [ -f "$REPORT_FILE" ]; then
                  # jq: JSON processor (parses JSON files)
                  # Query: Count all vulnerabilities in Results array
                  # 2>/dev/null: Suppress errors if jq fails
                  # || echo "0": Default to 0 if count fails
                  VULNS=$(jq '[.Results[]?.Vulnerabilities[]?] | length' "$REPORT_FILE" 2>/dev/null || echo "0")
                  echo "Found $VULNS vulnerabilities in $IMAGE"
                fi
              done
              
              echo "Scan complete. Reports saved to /reports"
              
              # ============================================
              # Production Enhancements (Future)
              # ============================================
              # Note: In production, you would:
              # 1. Upload reports to S3/object storage for long-term retention
              # 2. Send alerts via Slack/email if critical vulnerabilities found
              # 3. Integrate with CI/CD to block deployments with critical vulns
              # 4. Store reports in database for trend analysis
              # 5. Generate dashboards showing vulnerability trends over time
              
            # ============================================
            # Volume Mounts
            # ============================================
            volumeMounts:
            # ============================================
            # Option 1: Docker Socket (Current - for Docker environments)
            # ============================================
            # Docker socket: Allows Trivy to pull and scan images
            - name: docker-socket
              mountPath: /var/run/docker.sock
              # Why: Trivy needs access to Docker daemon to pull images
              # Note: This requires Docker to be running on the node
              # Use this if: You're using Docker (not MicroK8s) or have Docker installed
            
            # ============================================
            # Option 2: Containerd Socket (For MicroK8s)
            # ============================================
            # Uncomment below and comment out Docker socket above for MicroK8s:
            # - name: containerd-socket
            #   mountPath: /run/containerd/containerd.sock
            #   # Why: MicroK8s uses containerd, not Docker
            #   # Path: /run/containerd/containerd.sock (standard containerd socket)
            
            # Reports directory: Stores scan reports
            - name: reports
              mountPath: /reports
              # Reports are stored here temporarily
              # In production: Use PersistentVolume for long-term storage
          
          # ============================================
          # Volumes
          # ============================================
          volumes:
          # ============================================
          # Option 1: Docker Socket Volume (Current)
          # ============================================
          # Docker socket from host
          - name: docker-socket
            hostPath:
              path: /var/run/docker.sock  # Docker socket path on host
              type: Socket  # Kubernetes knows this is a socket file
            # Why: Allows container to communicate with Docker daemon
            # Security Note: This gives container access to Docker (use with caution)
          
          # ============================================
          # Option 2: Containerd Socket Volume (For MicroK8s)
          # ============================================
          # Uncomment below and comment out Docker socket above for MicroK8s:
          # - name: containerd-socket
          #   hostPath:
          #     path: /run/containerd/containerd.sock  # Containerd socket path on host
          #     type: Socket  # Kubernetes knows this is a socket file
          #   # Why: Allows container to communicate with containerd daemon
          #   # Note: For MicroK8s VM, this path is inside the VM
          #   # Security Note: This gives container access to containerd (use with caution)
          
          # Temporary storage for reports
          - name: reports
            emptyDir: {}  # Temporary directory (cleared when pod terminates)
            # emptyDir: Created when pod starts, deleted when pod terminates
            # In production: Use PersistentVolumeClaim for persistent storage

