# #### Frontend Deployment ####
# #### This tells Kubernetes HOW to run our frontend application ####
# #### A Deployment manages Pods (containers) and ensures they stay running ####

apiVersion: apps/v1  # #### API version for Deployments ####
kind: Deployment      # #### Resource type: Deployment manages Pods ####
metadata:
  name: frontend      # #### Name of this deployment ####
  namespace: payflow   # #### Deploy to payflow namespace ####
spec:
  replicas: 1         # #### Run 1 copy of the frontend (we'll scale later) ####
  selector:
    matchLabels:
      app: frontend   # #### This deployment manages pods with label "app: frontend" ####
  template:          # #### Template for creating Pods ####
    metadata:
      labels:
        app: frontend # #### Label this pod so the Deployment can find it ####
    spec:
      containers:
      - name: frontend
        image: veeno/frontend:latest  # #### Docker Hub image ####
        imagePullPolicy: Always  # #### Always pull latest image from Docker Hub ####
                                # #### Changed from IfNotPresent to ensure we get latest updates ####
        securityContext:
          allowPrivilegeEscalation: false  # #### Prevent privilege escalation attacks ####
          # Note: nginx:alpine runs as root initially to create cache directories,
          # then drops privileges internally. We allow root but prevent escalation.
          readOnlyRootFilesystem: false  # #### Allow writes (needed for logs, temp files) ####
        ports:
        - containerPort: 80  # #### Container listens on port 80 (nginx) ####
        # ============================================
        # NO REACT_APP_API_URL ENV VAR NEEDED
        # ============================================
        # Why: REACT_APP_* are BUILD-TIME variables in React
        # Setting them here in Kubernetes does NOTHING (already baked into JavaScript)
        # 
        # The Dockerfile already sets: ARG REACT_APP_API_URL=/api
        # So the built React app uses relative URLs: fetch('/api/auth/login')
        # 
        # Ingress routes www.payflow.local/api/* â†’ api-gateway:80
        # This works in ALL environments (local, staging, production)
        # ============================================
        resources:
          requests:
            memory: "64Mi"   # #### Minimum memory needed ####
            cpu: "50m"       # #### Minimum CPU (50 millicores = 0.05 CPU) ####
          limits:
            memory: "128Mi"  # #### Maximum memory allowed ####
            cpu: "100m"      # #### Maximum CPU ####

---
# #### Frontend Service ####
# #### This exposes the frontend deployment so it can be accessed ####
# #### A Service provides a stable IP and DNS name for pods ####

apiVersion: v1  # #### API version for Services ####
kind: Service   # #### Resource type: Service exposes pods ####
metadata:
  name: frontend      # #### Service name - other services can use this name ####
  namespace: payflow   # #### Deploy to payflow namespace ####
spec:
  selector:
    app: frontend     # #### Select pods with label "app: frontend" ####
  ports:
  - protocol: TCP
    port: 80          # #### Service listens on port 80 ####
    targetPort: 80    # #### Forward to pod's port 80 (nginx) ####
  type: ClusterIP     # #### Internal service (only accessible within cluster) ####
                     # #### We'll use Ingress or NodePort for external access later ####

